# 5.0 Migrate MSSQL Application

The first application that we are going to migrate is a simple Product Inventory web-based application front-end, backed backed by Microsoft SQL Server.  This application has been pre-deployed on your 3.11 cluster in the mssql-persistent namespace, using a single PV backed by NFS for persistent storage.

If we login to 3.11 cluster, we can see the app running:

```bash
$ oc get pods -n mssql-persistent
NAME                                    READY   STATUS    RESTARTS   AGE
mssql-app-deployment-6ffb46c5d6-n5fvv   1/1     Running   0          41m
mssql-deployment-1-xq4p4                1/1     Running   0          41m
```

Let's get the route to the application, and bring up the webUI.

```bash
$  oc get route -n mssql-persistent
NAME              HOST/PORT                                                       PATH   SERVICES     PORT   TERMINATION   WILDCARD
mssql-app-route   mssql-app-route-mssql-persistent.apps.cd76.events.opentlc.com          db-app-svc   5000                 None
```

![alt-text-1](./screenshots/mssql-product-catalog.png)

Let's go ahead and add a new product to the inventory.  Click on the +Add button and enter some data.

![alt-text-1](./screenshots/mssql-add-product.png)

You can see the application is functioning and state is being saved in the DB.  

![alt-text-1](./screenshots/mssql-added-product.png)

## 5.1 Migration Planning with CPMA

In planning our migration, the first step is to check out the CPMA generated report that we created and downloaded in Lab 3.

1. Point your browser to `File:///tmp/cpma/report.html`.

2. Open the `Cluster report` section of the report and click on `Namespaces`.

3. Scroll down until you see the entry for `mssql-persistent`.

![alt-text-1](./screenshots/cpma-mssql-report.png)

We see lots of detailed information about the mssql application and deployment, including the use of a custom Security Context Constraint (SCC).  We know from our CAM overview, that SCCs are not migrated as part of a Migration Plan.  So, we will need to apply the custom SCC onto our 4.1 Cluster prior to migrating the application.

Let's do this now.  The custom SCC yaml is available [here](www.google.com).  Please download to your local machine, as we will apply it in the next step.

### 5.1.1 Create MSSQL Security Context Constraint

1. Run the following to recreate MSSQL's `scc` on the destination cluster:
```bash
$ oc create -f files/mssql-scc.yaml
```

## 5.2 Using CAM

Next, let's open up the migration UI. Again, to get the route, run the following command on the destination cluster:
```bash
$ oc get routes migration -n mig -o jsonpath='{.spec.host}'
migration-mig.apps.cluster-dymurray-ocp4.dymurray-ocp4.mg.example.com
```

The screen should look something like:

![1](./screenshots/1.png?raw=true "1")

### 5.2.1 Add a Cluster

First thing we want to do is add the source OCP cluster we wish to migrate the
application from. Click `Add cluster`:

![1](./screenshots/1.png?raw=true "1")

Fill out the neccessary information. Be sure to see the [Setup
Document](./Setup.md#source-cluster) to get the service account token and URL.

![3-a](./screenshots/3-a.png?raw=true "3a")

When done, click `Check connection`. You should see a `Success!` message. Click
`Add`.

![3](./screenshots/3.png?raw=true "2")

## Setup an AWS S3 bucket as a replication repository

Next we want to add a replication repository. Click `Add Repository`:

![4](./screenshots/4.png?raw=true "4")

Fill out the AWS S3 bucket credential information.

![5](./screenshots/5.png?raw=true "5")

Click `Check connection` and you should see a `Success!` message appear if
everything looks good.

![5.a](./screenshots/5-a.png?raw=true "5a")

Click `Add` and view your repository on the main menu. Now that we have a
replication repository specified and both the source and destination clusters
defined, we can create a migration plan. Click `Add Plan`:

![6](./screenshots/6.png?raw=true "6")

## (Optional) View the application you wish to migrate

* Mediawiki
![mw3](./screenshots/mw3.png?raw=true "mw3")

* MSSQL
![mssql3](./screenshots/mssql3.png?raw=true "mssql3")

## Create a migration plan

Now that we have a replication repository specified and both the source and
destination clusters defined, we can create a migration plan. Click `Add Plan`:

![7](./screenshots/7.png?raw=true "7")

Fill out a plan name:

![8](./screenshots/8.png?raw=true "8")

Select the source cluster name:

![9](./screenshots/9.png?raw=true "9")

Select the namespace(s) you wish to migrate over. This will be either
`mssql-persistent` or `mediawiki`:

![10](./screenshots/10.png?raw=true "10")

Now we are displayed a list of persistent volumes associated with our
application workload. Select which type of action you would like to perform on
the PV. For this example, let's select `copy`:

![11](./screenshots/11.png?raw=true "11")

Select your migration targets. Select the previously created replication
repository and leave the target cluster field as `host`. Optionally change the
name of the namespace you wish to have on the destination cluster.

![12](./screenshots/12.png?raw=true "12")

After validating the migration plan, you will see a `Ready` message and you can
click `Close`:

![13](./screenshots/13.png?raw=true "13")

## Migrate the application workload

Now we can select `Migrate` or `Stage` on the application. Since we don't care
about downtime for this example, let's select `Migrate`:

![14](./screenshots/14.png?raw=true "14")

Optionally choose to *not* terminate the application on the source cluster.
Leave it unchecked and select `Migrate`.

![15](./screenshots/15.png?raw=true "15")

Once done, you should see `Migration Succeeded` on the migration plan:

![16](./screenshots/16.png?raw=true "16")


## Verify application is functioning on destination cluster

Let's first open the OCP 4.1 web console:

![console](./screenshots/dest.png?raw=true "console")

Click on the `mssql-persistent` or `mediawiki` namespace:

![ns](./screenshots/dest-project.png?raw=true "ns")

Click on the `mssql-app-deployment` or `mediawiki` deployment object to
retrieve the route:

![route](./screenshots/dest-route.png?raw=true "route")

Open the route and verify the application is functional:

* MSSQL
![app](./screenshots/dest-app.png?raw=true "app")

* Mediawiki
![mw4](./screenshots/mw4.png?raw=true "mw4")

## Bonus: Check out copied PV

To verify the application actually copied the PV data over to a new volume,
let's confirm we are no longer using an NFS volume. If everything worked as
expected, our OCP 4.1 cluster will use it's default storage class (gp2) to
provision an AWS EBS volume.

Click on the `Storage` tab in the web console:

![pv](./screenshots/pv1.png?raw=true "pv")

Click on the persistent volume and verify that it is using Amazon Elastic Block
Storage as the provisioner:

![pv2](./screenshots/pv2.png?raw=true "pv2")
